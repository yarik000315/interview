Junior
Загальні:
1.Які методи HTTP-запитів ви знаєте?
2.Які версії HTTP-протоколу вам відомі?
3.Які знаєте коди відповіді (стану) HTTP?
4.Що таке Cross-Origin Resource Sharing? Як усунути проблеми з CORS?
5.Що таке cookie?
6.Який максимальний розмір cookie?
7.Що означає директива use strict?
8.Чим JS відрізняється під час роботи на front-end і back-end?
9.Що таке статична і динамічна типізації?
10.Як клієнт взаємодіє із сервером?
11.Що таке REST?
12.Поясніть поняття мутабельність / іммутабельність? Які типи є мутабельними й навпаки?
13.Як шукати помилки в коді? Чи використовуєте дебагер?
14.Яких відомих людей зі світу JS знаєте?
JS Core
15.Які існують типи даних у JS?
16.Як перевірити, чи об’єкт є масивом?
17.Як перевірити, чи число є скінченним?
18.Як перевірити, що змінна рівна NaN?
19.Чим відрізняється поведінка isNaN() та Number.isNaN()?
20.Порівняйте ключові слова var, let, const.
21.Що таке область видимості?
22.Що таке деструктуризація?
23.Для чого призначені методи setTimeout і setInterval?
24.Порівняйте підходи роботи з асинхронним кодом: сallbacks vs promises vs async/await.
25.Чи можна записувати нові властивості / функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?
26.Назвіть методи масивів, які пам’ятаєте, і скажіть, для чого вони потрібні. 
27.Які перебираючі методи масиву знаєте? У чому їхня відмінність?
28.Як працюють оператори присвоєння / порівняння / рядкові / арифметичні / бітові тощо?
29.Опишіть призначення і принципи роботи з колекціями Map і Set. 
30.Що означає глибока (deep) та поверхнева (shallow) копія об’єкта? Як зробити кожну з них?
Функції:
31.Яка різниця між декларацією функції (function declaration) та функціональним виразом (function expression)?
32.Що таке анонімна функція?
33.Розкажіть про стрілкові функції (arrow function). В чому полягають відмінності стрілкових функцій від звичайних?
34.Що таке і для чого використовують IIFE (Immediately Invoked Function Expression)?
35.Що таке hoisting, як він працює для змінних і функцій?
36.Що таке замикання (closure) і які сценарії його використання?
37.Як ви розумієте замикання? Що буде виведено в консолі в цьому випадку?
var f = function() {
  console.log(1);
}

var execute = function(f) {
  setTimeout(f, 1000);
}

execute(f); // что выведет в консоль и почему

f = function() {
  console.log(2);
}
38.Що таке рекурсія?
39.Що означає ключове слово this?
40.Що таке втрата контексту, коли відбувається і як їй запобігти?
41.Методи функцій bind / call / apply — навіщо і в чому різниця?
Front-end
42.Що таке DOM?
43.Порівняйте атрибути підключення скрипту async і defer в HTML-документі. 
44.Яка різниця між властивостями HTML-елементів innerHTML і innerText?
45.Опишіть процес спливання (bubbling) подій у DOM.
46.Як зупинити спливання (bubbling) події?
47.Як зупинити дефолтну обробку події?
48.Чому дорівнює this в обробнику подій (event handler)?
49.Що таке LocalStorage і SessionStorage? Який максимальний розмір LocalStorage?
50.Як отримати висоту блоку? Його положення щодо меж документа?
51.Що таке webpack?
52.Чим відрізняється dev-збірка від prod?
Верстка
53.Що таке блокова модель CSS?
54.Які способи центрування блокового контенту по горизонталі та вертикалі знаєте?
55.Які підходи у верстці вам відомі (float, flex, grid, etc)?
56.Як зробити додаток responsive?
57.Які є принципи семантичної верстки?
58.Навіщо потрібні префікси для деяких CSS-властивостей (-webkit-, -moz- тощо)?
59.Як спростити написання кросбраузерних стилів?
60.Практичне завдання: прокоментувати та виправити приклад поганого CSS або HTML.
61.Що таке CSS-препроцесори? З якими працювали? Що нового вони приносять у стандартний CSS?
Angular
62.Перерахуйте основні компоненти фреймворку (модуль, роут, директива тощо).
63.У чому різниця між компонентом і директивою?
64.Розкажіть про життєвий цикл компонента.
65.Перерахуйте часто використовувані хуки життєвого циклу компонента та розкажіть, для чого вони потрібні?
66.У чому різниця між конструктором і ngOnInit-хуком?
67.Як захистити роут від несанкціонованого доступу? Які механізми надає для цього фреймворк?
68.Що таке Lazy loading, як і для чого використовується?
69.Яке призначення RouterOutlet?
70.Як компоненти можуть взаємодіяти один з одним?
71.Як створити two-way binding властивість для компонента?
72.Які типи форм є у фреймворку? У яких випадках і що краще використовувати?
73.Які стани є у форми і як це можна застосувати?
74.Навіщо потрібні сервіси? Як з ними працювати?
75.Що таке singleton-сервіси? Яке їхнє призначення? Спосіб створення?
76.Які є способи оголошення сервісів?
77.Для чого потрібні модулі? Скільки їх має бути в проєкті?
78.Навіщо потрібні загальні модулі (shared)?
79.Які переваги типізації в TypeScript?
80.Які можливості TypeScript можна використовувати для типізації (тут мають на увазі інтерфейси, типи, enum тощо)?
81.Яка різниця між інтерфейсом і класом?
82.У чому різниця між інтерфейсом і абстрактним класом?
83.Яка різниця між інтерфейсом і типом?
84.Що таке RxJS? Як він використовується у фреймворку? Які компоненти фреймворку тісно пов’язані з ним?
85.Чим відрізняються Observable і Promise?
86.Для чого потрібні Subjects? Які типи Subjects існують?
87.Як зробити кілька послідовних запитів до API за допомогою HTTP-сервісу і RxJS?
88.Яка різниця між switchMap, concatMap, mergeMap?
89.Як можна конфігурувати Angular-застосунок?
90.Навіщо потрібні environment-файли? Коли їх краще не використовувати?
91.У чому різниця між «розумним» (smart) і «дурним» (dumb) компонентами? У яких випадках застосовується кожен з них?
92.У чому різниця між NgForm, FormGroup і FormControl і як їх застосовують для побудови форм?
93.Навіщо потрібен і як працює async pipe?
94.Як стежити за розвитком фреймворку? Яких відомих людей, пов’язаних з Angular, знаєте / читаєте?
React
95.Чи працювали з класовими компонентами? У чому їхня особливість?
96.Які дані краще зберігати в стані компонента, а які передавати через пропси? Наведіть приклад.
97.Чи ознайомлені з хуками? У чому їхні переваги? Чи доводилося робити свої і з якою метою?
98.Чи ознайомлені з фрагментами та порталами? Навіщо вони потрібні?
99.Коли й для чого використовують рефи?
100.Які ви знаєте методи життєвого циклу компонента?
101.В якому методі життєвого циклу компонента краще робити запити на сервер? Чому?
102.В якому методі життєвого циклу компонента краще робити підписку і відписку від лістенера? Чому? Навіщо відписуватися?
103.Чи був досвід роботи з контекстом? Коли його варто використовувати?
104.У чому особливість PureComponent?
105.Чи працював з мемоізованими селекторами (memoized selectors)? Для чого їх використовують і який принцип роботи?
106.У чому бачите переваги бібліотеки React?
107.Чому бібліотека React швидка? Що таке Virtual DOM і Shadow DOM?
108.Навіщо в списках ключі? Чи можна робити ключами індекси елементів масиву? Коли це виправдано?
109.В чому основна ідея Redux? 
110.Робота зі стилями в React.
111.React — це бібліотека чи фреймворк? Яка різниця між цими двома поняттями.
112.Чи можна використовувати jQuery разом з React? Чому так / ні?
113.Що таке codemod?
114.Чи доводилося налаштовувати проєкт React з нуля? За допомогою яких інструментів ви це робили?
115.Перерахуйте всі бібліотеки, які використовували у зв’язці з React.
116.Що найскладніше доводилося реалізовувати за допомогою React?
Back-end
117.Що таке REPL?
118.Що таке streams в Node.js?
119.Що таке middleware?
120.Для чого використовують функцію setImmediate?
121.Навіщо потрібен app.param() в express?
122.Що таке token based authentication?
Бази даних
123.Напишіть простий запит для обчислення трьох авторів, у яких найбільше книг.
124.Напишіть запит, який вибирає останні три коментарі для конкретного користувача для двох таблиць: коментарі та користувачі.
125.Спроєктуйте просту схему бази даних для бібліотеки.
126.Для чого використовують SQL-оператор HAVING?
127.Навіщо використовують SQL-оператор LEFT JOIN?
128.Чим відрізняється embed- від reference-зв’язку в MongoDB?
129.В одному проєкті програмісти зберігають дані в MongoDB-колекції коментарів, використовуючи такі типи даних (дивіться нижче). Що поганого в цьому рішенні?
id: ObjectID
text: string
author_id: string
created_at: Date
130.У проєкті знадобилося внести зміни в структуру таблиць, додати кілька полів і індекси. Як програмісти будуть робити це на продакшені?
Інструменти
131.Щоразу, коли ви робите pull, чомусь трапляється конфлікт в останньому рядку в усіх файлах, які ви редагували. Що відбувається?
132.Що робить команда git fetch?
133.Які git hygiene підходи ви знаєте?
134.Що таке CI/CD? Для чого це потрібно?
Практичні завдання
135.Розкажіть, які є способи копіювання простого об’єкта типу obj = {a: 1, b: 2, c: 3}
136.Напишіть deep clone для об’єкта.
137.Назвіть різні способи, як поміняти місцями значення двох змінних.
138.Менеджер попросив у задачі поміняти статуси з «active, inactive» на «active, removed», але в коді фігурують тільки цифри й незрозуміло, який статус відповідає якій цифрі. Як допомогти майбутнім програмістам не лізти в документацію за кодом? Питання ставлять на конкретному прикладі з кодом.
139.Необхідно зробити мініпроєкт — список користувачів з формою створення/редагування користувача:
1.	Для зберігання користувачів використовуйте Firebase (це безкоштовно).
2.	Для стилізації використовуйте Bootstrap.
3.	Мінімальний набір полів користувача:

o	ім’я;
o	прізвище;
o	електронна пошта;
o	телефон (у форматі +380 (XX) XXX-XX-XX);
o	дата народження;
o	буде плюсом — додавання аватара та можливість crop-картинки.
4.	Список користувачів повинен мати можливість фільтрації та пагінацію.
5.	Проєкт має містити README-файл з кроками для запуску.

 
---------------------------------------------------------------------------------------------------------------------------------------------------------





THE ANSWERS (Відповіді)


---------------------------------------------------------------------------------------------------------------------------------------------------------

1.Які методи HTTP-запитів ви знаєте?
методи запитів (request methods)
GET
Метод GET запитує представлення вказаного ресурсу. Запити, які використовують GET, повинні лише отримувати дані.
HEAD
Метод HEAD запитує відповідь, ідентичну запиту GET, але без тіла.
POST
Метод POST використовується для відправки об'єкта на вказаний ресурс, часто викликаючи зміну стану або побічних ефектів на сервері
PUT
Метод PUT замінює всі поточні представлення цільового ресурсу на корисне навантаження, що вказане в запиті.
DELETE
Метод DELETE видаляє вказаний ресурс.
CONNECT
Метод CONNECT встановлює тунель до сервера, ідентифікованого цільовим ресурсом.
OPTIONS
Метод OPTIONS використовується для опису варіантів зв'язку до цільового ресурсу.
TRACE
Метод TRACE виконує тест зворотного зв'язку по шляху до цільового ресурсу.
PATCH
Метод PATCH використовується для застосування часткових модифікацій в ресурсі.
---------------------------------------------------------------------------------------------------------------------------------------------------------

2.Які версії HTTP-протоколу вам відомі?
HTTP — протокол передачі даних, що використовується в комп'ютерних мережах. Назва скорочена від HyperText Transfer Protocol, протокол передачі гіпертекстових документів 
Метод HTTP безопасен, если он не изменяет состояние сервера. Другими словами, метод безопасен, если он ведет к операции только для чтения. Несколько общих методов HTTP безопасны: GET, HEADилиOPTIONS. Все безопасные методы также являются идемпотентными , но не все идемпотентные методы безопасны. Например, PUTи DELETEоба идемпотентная , но небезопасно.
На данный момент есть четыре стандарта HTTP протокола:

Стандарт HTTP/0.9 – версия протокола HTTP 0.9 была разработана в 1991 году в ЦЕРН Тимом Бернерсом-Ли. Тим разработал HTTP протокол для облегчения доступа и создания навигации при помощи гипертекста. Протокол версии 0.9 был призван упорядочить взаимодействие между клиентом и сервером в сети. После появления стандарта HTTP/0.9 появилось разделение функций между клиентом и сервером при их взаимодействии. Стандарт HTTP/0.9 содержит в себе основы синтаксиса и семантики протокола HTTP.

В 1996 году был выпущен информационный документ RFC 1945 (стандарт HTTP/1.0). Данный документ стал основой для реализации приложений и компонентов с использованием протокола HTTP версии 1.0. Кстати, разработчики могут идентифицировать свои приложения при передаче HTTP сообщений.

В 1997 году была выпущена версия протокола HTTP1: был разработан стандарт HTTP/1.1 и описан он в документе RFC 2068. В 1999 году был доработан стандарт HTTP/1.1 (именно стандарт HTTP/1.1). Доработки коснулись: общего дизайна стандарта, формулировки и разъяснения некоторых терминов, исправлены опечатки, даны некоторые разъяснения по взаимодействию клиента и HTTP сервера в спорных ситуациях. Основным нововведением в версию протокола HTTP 1.1 был режим постоянного соединения (можете почитать про постоянные HTTP соединения), другими словами: за одно соединение можно было отправлять несколько HTTP запросов и получать несколько HTTP ответов в том порядке, в котором делались запросы. Вторым основным нововведение в версию протокола HTTP 1.1 является то, что теперь клиент при установке соединения с сервером должен обязательно посылать имя хоста в специальном поле HTTP заголовка (данное нововведение привело к массовому распространению виртуальных хостингов). На данный момент большинство приложений для своей работы используют HTTP протокол версии 1.1. Стоит заметить, что версия HTTP протокола является очень важным HTTP параметром, который должны использовать все приложения. Так же замечу, что независимо от номера стандарта HTTP протокол предъявляет требования к приложениям, которые его используют.

2015 году была опубликована финальная версия черновика протокола HTTP 2, это еще не стандарт, но черновик нам «показывает» куда будет двигаться развитие интернета. Версия протокола HTTP 2 является бинарной. В версии протокола HTTP 2 будет поддерживаться мультиплексирование (объединение) запросов, поскольку появится объединение, появится и приоритет запросов и многое другое, думаю, в завершении цикла заметок по HTTP мы познакомимся со всеми нововведениями HTTP.
---------------------------------------------------------------------------------------------------------------------------------------------------------

3.Які знаєте коди відповіді (стану) HTTP?
Код состояния HTTP зашифрован в 3-х цифрах. Первая цифра указывает на класс состояния (группа кодов). Вторая и третья цифра – порядковый номер кода ответа.

Код состояния HTTP возвращается сервером. Он является частью первой строки ответа сервера при запросах по протоколу HTTP и указывает на то, был ли успешно выполнен определенный HTTP запрос.

Коды сгруппированы в 5 классов: информационные (1xx), успешные (2xx), перенаправления (3xx), ошибки клиента (4xx) и ошибки сервера (5xx).

Краткая характеристика классов:

1xx (информационные): в этот класс выделены коды, информирующие о процессе передачи
2xx (успешные): сообщения данного класса информируют о случаях успешного принятия и обработки запроса клиента
3xx (перенаправления): коды этого класса сообщают клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило, по другому URI)
4xx (ошибки клиента): коды данного класса предназначены для указания ошибок со стороны клиента
5xx (ошибки сервера): коды ответов этого класса выделены под случаи неудачного выполнения операции по вине сервера

#Информационные	
100	Continue (Продолжай)	Сервер удовлетворен начальными сведениями о запросе, клиент может продолжать пересылать заголовки. Появился в версии HTTP/1.1.
101	Switching Protocol (Переключение протоколов)	Сервер предлагает перейти на более подходящий для указанного ресурса протокол; список предлагаемых протоколов сервер обязательно указывает в поле заголовка Upgrade. Если клиента это заинтересует, то он посылает новый запрос с указанием другого протокола.
102	Processing (Идет обработка)	Запрос принят сервером, но на его обработку понадобится длительное время. Этот ответ используется для того, чтобы клиент не разорвал соединение из-за превышения времени ожидания. Клиент при получении такого ответа должен сбросить таймер и дожидаться следующей команды в обычном режиме. Появился в WebDAV.
#Успешные
200	ОК	Успешно обработанный запрос. «Успешность» зависит от метода HTTP, который был запрошен:
GET: «ПОЛУЧИТЬ». Запрошенный ресурс был найден и передан в теле ответа.
HEAD: «ЗАГОЛОВОК». Заголовок передан в ответе.
POST: «ПОСЫЛКА». Ресурс, описывающий результат действия сервера на запрос, передан в теле ответа.
TRACE: «ОТСЛЕЖИВАТЬ». Тело ответа содержит тело запроса полученного сервером.
201	Created (Создано)	Запрос успешно выполнен и в результате был создан новый ресурс. Этот код обычно присылается в ответ на запрос PUT «ПОМЕСТИТЬ».
202	Accepted (Принято)	Запрос принят, но еще не обработан. Клиенту не обязательно дожидаться окончательной передачи сообщения, так как может быть начат очень долгий процесс.
203	Non-Authoritative Information (Информация не авторитетна)	Этот код ответа означает, что информация, которая была возвращена, была предоставлена не сервером, а каким-либо другим источником. Аналогично ответу 200, но в этом случае передаваемая информация была взята не из первичного источника и поэтому может быть неактуальной.
204	No Content (Нет содержимого)	Сервер успешно обработал запрос, но в ответе были переданы только заголовки без тела сообщения. Клиент не должен обновлять содержимое документа, но может применить к нему полученные метаданные. Клиент может использовать их для обновления кэшированных заголовков для предыдущих ресурсов.
205	Reset Content (Сбросить содержимое)	Этим кодом сервер обязывает клиента сбросить введенные пользователем данные. Тела сообщения сервер при этом не передает и документ обновлять не обязательно.
206	Partial Content (Частичное содержимое)	Сервер удачно выполнил частичный GET-запрос, возвратив только часть контента. В заголовке Content-Range сервер указывает байтовые диапазоны содержимого. Особое внимание при работе с подобными ответами следует уделить кэшированию.
#Перенаправления
300	Multiple Choice (Множественный выбор)	Этот код ответа присылается, когда запрос имеет более чем один из возможных ответов (по типу MIME, по языку или по другим характеристикам). Сервер передает с сообщением список альтернатив, давая возможность сделать выбор клиенту автоматически или пользователю.
301	Moved Permanently (Перемещен на постоянной основе)	Этот код ответа означает, что URI запрашиваемого ресурса был изменен. Новый URI указывается в поле Location заголовка.
302	Found (Найдено); Moved Temporarily (Перемещен временно)	Этот код ответа означает, что запрошенный ресурс временно доступен по другому URI, указанному в поле Location заголовка.
303	See Other (Смотреть другое)	Сервер отправил этот ответ, чтобы направить клиента для получения запрашиваемого ресурса по другому URI с использованием метода GET. Другой URI указывается в поле Location заголовка.
304	Not Modified (Не изменялось)	Этот ответ используется для кэширования. Он сообщает клиенту, что ответ не был изменен. Таким образом, клиент может продолжать использовать ту же кэшированную версию ответа. При этом сообщение сервера не должно содержать тела.
305	Use Proxy (Используй прокси)	Запрос к запрашиваемому ресурсу должен осуществляться через прокси-сервер, URI которого указан в поле Location заголовка. Этот код ответа не поддерживается в основном из соображений безопасности.
306	неиспользуемый	Этот код ответа больше не используется, в настоящее время зарезервирован.
307	Temporary Redirect (Временная переадресация)	Запрашиваемый ресурс на короткое время доступен по другому URI, указанному в поле Location заголовка. Имеет ту же семантику, что и 302 Found код ответа HTTP, за исключением того, что клиент не должен изменять используемый HTTP-метод: если использовался POST в первом запросе, он должен использовать POST и во втором запросе.
308	Permanent Redirect (Постоянная переадресация)	Это означает, что ресурс теперь постоянно находится по другому URI, указанному в поле Location заголовка. Имеет ту же семантику, что и код ответа HTTP 301 Moved Permanently, за исключением того, что клиент не должен изменять используемый HTTP-метод: если использовался POST в первом запросе, он должен использовать POST и во втором запросе.
#Ошибки клиента
400	Bad Request (Плохой запрос)	Этот ответ означает, что сервер не смог понять клиентский запрос из-за синтаксической ошибки.
401	Unauthorized (Не авторизован)	Для получения запрошенного ответа требуется аутентификация. Это похоже на 403 ответ, но в этом случае возможна аутентификация. В заголовке ответ должен содержать поле WWW-Authenticate с перечнем условий аутентификации.
402	Payment Required (Требуется оплата)	Этот код ответа зарезервирован для будущего использования. Первоначальная цель создания этого кода заключалась в использовании его для цифровых платежных систем, однако в настоящее время он не используется.
403	Forbidden (Запрещено)	Сервер понял запрос, но он отказывается его выполнять из-за ограничений в доступе для клиента к указанному ресурсу. Клиент не имеет прав доступа к контенту, поэтому сервер отказывается дать правильный ответ. Наиболее вероятными причинами ограничения может служить попытка доступа к системным ресурсам веб-сервера (например, файлам .htaccess или .htpasswd) или к файлам, доступ к которым был закрыт с помощью конфигурационных файлов.
404	Not Found (Не найдено)	Сервер не может найти запрашиваемый ресурс. Основная причина — ошибка в написании адреса Web-страницы. Этот код ответа, вероятно, является самым известным из-за его распространенности в Интернете.
405	Method Not Allowed (Метод не поддерживается)	Метод запроса известен серверу, но был отключен и не может быть использован. В ответе сервер должен указать доступные методы в заголовке Allow, разделив их запятой. Два обязательных метода: GET и HEAD никогда не должны быть отключены и не должны возвращать этот код ошибки.
406	Not Acceptable (Недопустимо)	Запрошенный URI не может удовлетворить переданным в заголовке характеристикам. Если метод был не HEAD, то сервер должен вернуть список допустимых характеристик для данного ресурса.
407	Proxy Authentication Required (Требуется аутентификация прокси)	Этот ответ похож на 401, но здесь проверка подлинности (аутентификация) производится для прокси-сервера.
408	Request Timeout (Истекло время ожидания)	Время ожидания сервером передачи от клиента истекло. Это означает, что сервер хотел бы отключить это неиспользуемое соединение. Обратите внимание, что некоторые серверы просто закрывают соединение без отправки этого сообщения.
409	Conflict (Конфликт)	Этот ответ будет отправлен, когда запрос будет конфликтовать с текущим состоянием сервера. Такое возможно, например, когда два клиента пытаются изменить ресурс с помощью метода PUT.
410	Gone (Удален)	Этот ответ будет отправлен, когда запрашиваемый контент по указанному URL был удален с сервера. Серверу в этом случае неизвестно и местоположение альтернативного документа (например, копии).
411	Length Required (Требуется длина)	Сервер отклонил запрос, потому что поле заголовка Content-Length не определено, а сервер требует его. Такой ответ естественен для запросов типа POST и PUT. Например, если по указанному URI производится загрузка файлов, а на сервере стоит ограничение на их объем.
412	Precondition Failed (Условие ложно)	Клиент указал условные поля в заголовках запроса (например, If-Match и др.), которые сервер не выполняет.
413	Payload Too Large. Ранее — Request Entity Too Large (Запрошен слишком большой объект)	Объект запроса больше ограничений, которые определены на сервере. Сервер может закрыть соединение, чтобы прекратить дальнейшую передачу запроса или вернуть поле заголовка Retry-After с указанием времени, по истечении которого можно повторить аналогичный запрос.
414	URI Too Long. Ранее — Request-URI Too Long (Запрошен слишком большой URI)	Запрошенный клиентом URI слишком длинный для обработки сервером. Такую ошибку можно спровоцировать, например, когда клиент пытается передать длинные параметры через метод GET, а не POST.
415	Unsupported Media Type (Неподдерживаемый тип данных)	Формат запрашиваемых типов данных не поддерживается сервером, поэтому сервер отклоняет запрос. По каким-то причинам сервер отказывается работать с указанным типом данных при данном методе.
416	Range Not Satisfiable. Ранее — Requested Range Not Satisfiable (Диапазон недостижим)	Диапазон, указанный полем заголовка Range в запросе, не может быть выполнен; возможно, что диапазон находится вне размера данных целевого URI и отсутствует поле If-Range.
417	Expectation Failed (Ошибка ожидания)	Этот код ответа означает, что ожидание, указанное полем заголовка Expect запроса, не может быть выполнено сервером.
421	Misdirected Request (Неверно адресованный запрос)	Запрос был перенаправлен на сервер, не способный дать ответ.
451	Unavailable For Legal Reasons (Недоступно по юридическим причинам)	Доступ к ресурсу закрыт по юридическим причинам (например, по требованию органов государственной власти или по требованию правообладателя в случае нарушения авторских прав). Введено в черновике IETF за авторством Google, при этом код ошибки является отсылкой к роману Рэя Брэдбери «451 градус по Фаренгейту». Был добавлен в стандарт 21 декабря 2015 года.
#Ошибки сервера
500	Internal Server Error (Внутренняя ошибка сервера)	Сервер столкнулся с ситуацией, когда он не знает, как ему поступить. Любая внутренняя ошибка сервера, которая не входит в рамки остальных ошибок класса.
501	Not Implemented (Не реализовано)	Метод запроса не поддерживается сервером и не может быть обработан. Типичный ответ для случаев, когда сервер не понимает указанный в запросе метод. Единственными методами, которые требуются сервером для поддержки (и, следовательно, не должны возвращать этот код), являются GET и HEAD.
502	Bad Gateway (Плохой шлюз)	Этот ответ об ошибке означает, что сервер, работая в качестве шлюза для получения ответа, необходимого для обработки запроса, получил неверный ответ. Сервер, выступая в роли шлюза или прокси-сервера, получил недействительное ответное сообщение от вышестоящего сервера.
503	Service Unavailable (Сервис недоступен)	Сервер не готов обрабатывать запрос. Сервер временно не имеет возможности обрабатывать запросы по техническим причинам (обслуживание, перегрузка и прочее). Обратите внимание, что вместе с этим ответом следует отправить удобную для пользователя страницу, объясняющую проблему. Эти ответы должны использоваться для временных условий, и HTTP-заголовок Retry-After должен, по возможности, содержать расчетное время до восстановления обслуживания. Веб-мастер также должен следить за заголовками, связанными с кэшированием, которые отправляются вместе с этим ответом, так как эти временные ответы обычно не кэшируются.
504	Gateway Timeout (Шлюз не отвечает)	Этот ответ об ошибке предоставляется, когда сервер действует как шлюз и не может получить ответ вовремя. Сервер в роли шлюза или прокси-сервера не дождался ответа от вышестоящего сервера для завершения текущего запроса.
505	HTTP Version Not Supported (Версия HTTP не поддерживается)	Версия протокола HTTP, используемая в запросе, не поддерживается сервером (либо сервер отказывается поддерживать указанную версию).
509	Bandwidth Limit Exceeded (Исчерпана пропускная ширина канала)	Этот код используется при превышении веб-площадкой отведенного ей ограничения на потребление трафика. В данном случае владельцу площадки следует обратиться к своему хостинг-провайдеру. В настоящий момент данный код не описан ни в одном RFC и используется только модулем «bw/limited», входящим в панель управления хостингом cPanel, где и был введен.
---------------------------------------------------------------------------------------------------------------------------------------------------------

4.Що таке Cross-Origin Resource Sharing? Як усунути проблеми з CORS?
5.Що таке cookie?
6.Який максимальний розмір cookie?
7.Що означає директива use strict?
8.Чим JS відрізняється під час роботи на front-end і back-end?
9.Що таке статична і динамічна типізації?
---------------------------------------------------------------------------------------------------------------------------------------------------------
10.Як клієнт взаємодіє із сервером?
Клієнти і сервери взаємодіють, обмінюючись поодинокими повідомленнями (а не потоком даних). Повідомлення, відправлені клієнтом, зазвичай веб-браузером, називаються запитами, а повідомлення, відправлені сервером, називаються відповідями.
---------------------------------------------------------------------------------------------------------------------------------------------------------
11.Що таке REST?
12.Поясніть поняття мутабельність / іммутабельність? Які типи є мутабельними й навпаки?
13.Як шукати помилки в коді? Чи використовуєте дебагер?
14.Яких відомих людей зі світу JS знаєте?
JS Core
15.Які існують типи даних у JS?
16.Як перевірити, чи об’єкт є масивом?
17.Як перевірити, чи число є скінченним?
18.Як перевірити, що змінна рівна NaN?
19.Чим відрізняється поведінка isNaN() та Number.isNaN()?
20.Порівняйте ключові слова var, let, const.
21.Що таке область видимості?
22.Що таке деструктуризація?
23.Для чого призначені методи setTimeout і setInterval?
24.Порівняйте підходи роботи з асинхронним кодом: сallbacks vs promises vs async/await.
25.Чи можна записувати нові властивості / функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?
26.Назвіть методи масивів, які пам’ятаєте, і скажіть, для чого вони потрібні. 
27.Які перебираючі методи масиву знаєте? У чому їхня відмінність?
28.Як працюють оператори присвоєння / порівняння / рядкові / арифметичні / бітові тощо?
29.Опишіть призначення і принципи роботи з колекціями Map і Set. 
30.Що означає глибока (deep) та поверхнева (shallow) копія об’єкта? Як зробити кожну з них?
Функції:
31.Яка різниця між декларацією функції (function declaration) та функціональним виразом (function expression)?
32.Що таке анонімна функція?
33.Розкажіть про стрілкові функції (arrow function). В чому полягають відмінності стрілкових функцій від звичайних?
34.Що таке і для чого використовують IIFE (Immediately Invoked Function Expression)?
35.Що таке hoisting, як він працює для змінних і функцій?
36.Що таке замикання (closure) і які сценарії його використання?
37.Як ви розумієте замикання? Що буде виведено в консолі в цьому випадку?
var f = function() {
  console.log(1);
}

var execute = function(f) {
  setTimeout(f, 1000);
}

execute(f); // что выведет в консоль и почему

f = function() {
  console.log(2);
}
38.Що таке рекурсія?
39.Що означає ключове слово this?
40.Що таке втрата контексту, коли відбувається і як їй запобігти?
41.Методи функцій bind / call / apply — навіщо і в чому різниця?
Front-end
42.Що таке DOM?
43.Порівняйте атрибути підключення скрипту async і defer в HTML-документі. 
44.Яка різниця між властивостями HTML-елементів innerHTML і innerText?
45.Опишіть процес спливання (bubbling) подій у DOM.
46.Як зупинити спливання (bubbling) події?
47.Як зупинити дефолтну обробку події?
48.Чому дорівнює this в обробнику подій (event handler)?
49.Що таке LocalStorage і SessionStorage? Який максимальний розмір LocalStorage?
50.Як отримати висоту блоку? Його положення щодо меж документа?
51.Що таке webpack?
52.Чим відрізняється dev-збірка від prod?
Верстка
53.Що таке блокова модель CSS?
54.Які способи центрування блокового контенту по горизонталі та вертикалі знаєте?
55.Які підходи у верстці вам відомі (float, flex, grid, etc)?
56.Як зробити додаток responsive?
57.Які є принципи семантичної верстки?
58.Навіщо потрібні префікси для деяких CSS-властивостей (-webkit-, -moz- тощо)?
59.Як спростити написання кросбраузерних стилів?
60.Практичне завдання: прокоментувати та виправити приклад поганого CSS або HTML.
61.Що таке CSS-препроцесори? З якими працювали? Що нового вони приносять у стандартний CSS?
Angular
62.Перерахуйте основні компоненти фреймворку (модуль, роут, директива тощо).
63.У чому різниця між компонентом і директивою?
64.Розкажіть про життєвий цикл компонента.
65.Перерахуйте часто використовувані хуки життєвого циклу компонента та розкажіть, для чого вони потрібні?
66.У чому різниця між конструктором і ngOnInit-хуком?
67.Як захистити роут від несанкціонованого доступу? Які механізми надає для цього фреймворк?
68.Що таке Lazy loading, як і для чого використовується?
69.Яке призначення RouterOutlet?
70.Як компоненти можуть взаємодіяти один з одним?
71.Як створити two-way binding властивість для компонента?
72.Які типи форм є у фреймворку? У яких випадках і що краще використовувати?
73.Які стани є у форми і як це можна застосувати?
74.Навіщо потрібні сервіси? Як з ними працювати?
75.Що таке singleton-сервіси? Яке їхнє призначення? Спосіб створення?
76.Які є способи оголошення сервісів?
77.Для чого потрібні модулі? Скільки їх має бути в проєкті?
78.Навіщо потрібні загальні модулі (shared)?
79.Які переваги типізації в TypeScript?
80.Які можливості TypeScript можна використовувати для типізації (тут мають на увазі інтерфейси, типи, enum тощо)?
81.Яка різниця між інтерфейсом і класом?
82.У чому різниця між інтерфейсом і абстрактним класом?
83.Яка різниця між інтерфейсом і типом?
84.Що таке RxJS? Як він використовується у фреймворку? Які компоненти фреймворку тісно пов’язані з ним?
85.Чим відрізняються Observable і Promise?
86.Для чого потрібні Subjects? Які типи Subjects існують?
87.Як зробити кілька послідовних запитів до API за допомогою HTTP-сервісу і RxJS?
88.Яка різниця між switchMap, concatMap, mergeMap?
89.Як можна конфігурувати Angular-застосунок?
90.Навіщо потрібні environment-файли? Коли їх краще не використовувати?
91.У чому різниця між «розумним» (smart) і «дурним» (dumb) компонентами? У яких випадках застосовується кожен з них?
92.У чому різниця між NgForm, FormGroup і FormControl і як їх застосовують для побудови форм?
93.Навіщо потрібен і як працює async pipe?
94.Як стежити за розвитком фреймворку? Яких відомих людей, пов’язаних з Angular, знаєте / читаєте?
React
95.Чи працювали з класовими компонентами? У чому їхня особливість?
96.Які дані краще зберігати в стані компонента, а які передавати через пропси? Наведіть приклад.
97.Чи ознайомлені з хуками? У чому їхні переваги? Чи доводилося робити свої і з якою метою?
98.Чи ознайомлені з фрагментами та порталами? Навіщо вони потрібні?
99.Коли й для чого використовують рефи?
100.Які ви знаєте методи життєвого циклу компонента?
101.В якому методі життєвого циклу компонента краще робити запити на сервер? Чому?
102.В якому методі життєвого циклу компонента краще робити підписку і відписку від лістенера? Чому? Навіщо відписуватися?
103.Чи був досвід роботи з контекстом? Коли його варто використовувати?
104.У чому особливість PureComponent?
105.Чи працював з мемоізованими селекторами (memoized selectors)? Для чого їх використовують і який принцип роботи?
106.У чому бачите переваги бібліотеки React?
107.Чому бібліотека React швидка? Що таке Virtual DOM і Shadow DOM?
108.Навіщо в списках ключі? Чи можна робити ключами індекси елементів масиву? Коли це виправдано?
109.В чому основна ідея Redux? 
110.Робота зі стилями в React.
111.React — це бібліотека чи фреймворк? Яка різниця між цими двома поняттями.
112.Чи можна використовувати jQuery разом з React? Чому так / ні?
113.Що таке codemod?
114.Чи доводилося налаштовувати проєкт React з нуля? За допомогою яких інструментів ви це робили?
115.Перерахуйте всі бібліотеки, які використовували у зв’язці з React.
116.Що найскладніше доводилося реалізовувати за допомогою React?
Back-end
117.Що таке REPL?
118.Що таке streams в Node.js?
119.Що таке middleware?
120.Для чого використовують функцію setImmediate?
121.Навіщо потрібен app.param() в express?
122.Що таке token based authentication?
Бази даних
123.Напишіть простий запит для обчислення трьох авторів, у яких найбільше книг.
124.Напишіть запит, який вибирає останні три коментарі для конкретного користувача для двох таблиць: коментарі та користувачі.
125.Спроєктуйте просту схему бази даних для бібліотеки.
126.Для чого використовують SQL-оператор HAVING?
127.Навіщо використовують SQL-оператор LEFT JOIN?
128.Чим відрізняється embed- від reference-зв’язку в MongoDB?
129.В одному проєкті програмісти зберігають дані в MongoDB-колекції коментарів, використовуючи такі типи даних (дивіться нижче). Що поганого в цьому рішенні?
id: ObjectID
text: string
author_id: string
created_at: Date
130.У проєкті знадобилося внести зміни в структуру таблиць, додати кілька полів і індекси. Як програмісти будуть робити це на продакшені?
Інструменти
131.Щоразу, коли ви робите pull, чомусь трапляється конфлікт в останньому рядку в усіх файлах, які ви редагували. Що відбувається?
132.Що робить команда git fetch?
133.Які git hygiene підходи ви знаєте?
134.Що таке CI/CD? Для чого це потрібно?
Практичні завдання
135.Розкажіть, які є способи копіювання простого об’єкта типу obj = {a: 1, b: 2, c: 3}
136.Напишіть deep clone для об’єкта.
137.Назвіть різні способи, як поміняти місцями значення двох змінних.
138.Менеджер попросив у задачі поміняти статуси з «active, inactive» на «active, removed», але в коді фігурують тільки цифри й незрозуміло, який статус відповідає якій цифрі. Як допомогти майбутнім програмістам не лізти в документацію за кодом? Питання ставлять на конкретному прикладі з кодом.
139.Необхідно зробити мініпроєкт — список користувачів з формою створення/редагування користувача:
6.	Для зберігання користувачів використовуйте Firebase (це безкоштовно).
7.	Для стилізації використовуйте Bootstrap.
8.	Мінімальний набір полів користувача:

o	ім’я;
o	прізвище;
o	електронна пошта;
o	телефон (у форматі +380 (XX) XXX-XX-XX);
o	дата народження;
o	буде плюсом — додавання аватара та можливість crop-картинки.
9.	Список користувачів повинен мати можливість фільтрації та пагінацію.
10.	Проєкт має містити README-файл з кроками для запуску.

 


